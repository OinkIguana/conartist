# TODO: use this to generate the GraphQL functions and replace the custom
#       GraphQL stuff in the clients.
#       Probably use Apollo, and have to patch jahewson or port ApolloJS for Elm

scalar NaiveDate
scalar DateTimeUtc
scalar DateTimeFixedOffset
scalar Money

type Query {
  user(id: Int): User!
  userConvention(id: Int, code: String!): FullUserConvention!
  convention(date: Date, page: Int, limit: Int): ConventionPage!
}

type User {
  id: Int!
  name: String!
  email: String!
  keys: Int!
  joinDate: DateTimeUtc!
  productTypes: [ProductType]!
  products: [ProductInInventory]!
  prices: [PriceRow]!
  conventions: [FullUserConvention]!
}

type ProductType {
  id: Int!
  name: String!
  color: Int!
  discontinued: Boolean!
}

type ProductInInventory {
  id: Int!
  typeId: Int!
  name: String!
  quantity: Int!
  discontinued: Boolean!
}

type PricePairOut {
  quantity: Int!
  price: Money!
}
type Price {
  typeId: Int!
  productId: Int
  prices: [PricePairOut]!
}

type PriceRow {
  index: Int!
  typeId: Int!
  productId: Int
  quantity: Int!
  price: Money!
}

type Record {
  id: Int!
  products: [Int]!
  price: Money!
  time: DateTimeUtc!
}

type Expense {
  id: Int!
  price: Money!
  category: String!
  description: String!
  time: DateTimeUtc!
}

type FullUserConvention {
  id: Int!
  conId: Int!
  code: String!
  name: String!
  start: DateTimeUtc!
  end: DateTimeUtc!
  productTypes: [ProductType]!
  products(includeAll: Boolean): [ProductInInventory]!
  condensedPrices(includeAll: Boolean): [Price]!
  prices(includeAll: Boolean): [PriceRow]!
  records: [Record]!
  expenses: [Expense]!
}

type Convention {
  id: Int!
  code: String!
  name: String!
  start: DateTimeUtc!
  end: DateTimeUtc!
}

type ConventionPage {
  pages: Int!
  page: Int!
  data: [Convention]!
}

type Mutation {
  changeUserEmail(userId: Int, email: String!): User!
  changeUserPassword(userId: Int, password: String!): User!
  changeUserName(userId: Int, name: String!): User!
  addUserKeys(userId: Int, quantity: Int!): User!

  addUserProductType(userId: Int, productType: ProductTypeAdd!): ProductType!
  modUserProductType(userId: Int, productType: ProductTypeMod!): ProductType!

  addUserProduct(userId: Int, product: ProductAdd!): ProductInInventory!
  modUserProduct(userId: Int, product: ProductMod!): ProductInInventory!

  addUserPrice(userId: Int, price: PriceAdd!): Price!
  delUserPrice(userId: Int, price: PriceDel!): Boolean!

  addUserConvention(userId: Int, conCode: String!): Convention!
  delUserConvention(userId: Int, conCode: String!): Boolean!

  addUserRecord(userId: Int, record: RecordAdd!): Record!
  modUserRecord(userId: Int, record: RecordMod!): Record!
  delUserRecord(userId: Int, record: RecordDel!): Record!

  addUserExpense(userId: Int, expense: ExpenseAdd!): Expense!
  modUserExpense(userId: Int, expense: ExpenseMod!): Expense!
  delUserExpense(userId: Int, expense: ExpenseDel!): Expense!
}

input ProductTypeAdd {
  name: String!
  color: Int!
}
input ProductTypeMod {
  typeId: Int!
  name: String
  color: Int
  discontinued: Boolean
}

input ProductAdd {
  typeId: Int!
  name: String!
  quantity: Int!
}
input ProductMod {
  productId: Int!
  name: String
  quantity: Int
  discontinued: Boolean
}

input PricePairIn {
  quantity: Int!
  price: Money!
}
input PriceAdd {
  typeId: Int!
  productId: Int
  prices: [PricePairIn]!
}
input PriceDel {
  typeId: Int!
  productId: Int
}

input RecordAdd {
  conId: Int!
  products: [Int]!
  price: Money!
  time: DateTimeFixedOffset!
}
input RecordMod {
  recordId: Int!
  products: [Int]
  price: Float
}
input RecordDel {
  recordId: Int!
}

input ExpenseAdd {
  conId: Int!
  price: Money!
  category: String!
  description: String!
  time: DateTimeFixedOffset!
}
input ExpenseMod {
  expenseId: Int!
  price: Float
  category: String
  description: String
}
input ExpenseDel {
  expenseId: Int!
}

fragment ProductTypeFragment on ProductType {
  id
  name
  color
  discontinued
}

fragment ProductFragment on ProductInInventory {
  id
  typeId
  name
  quantity
  discontinued
}

fragment PriceRowFragment on PriceRow {
  index
  typeId
  productId
  quantity
  price
}

fragment MetaConventionFragment on FullUserConvention {
  id
  code
  name
  start
  end
}

fragment RecordFragment on Record {
  id
  products
  price
  time
}

fragment ExpenseFragment on Expense {
  id
  category
  description
  price
  time
}

fragment FullConventionFragment on FullUserConvention {
  ...MetaConventionFragment
  products(includeAll: true) { ...ProductFragment }
  productTypes { ...ProductTypeFragment }
  prices(includeAll: true) { ...PriceRowFragment }
  records { ...RecordFragment }
  expenses { ...ExpenseFragment }
}

query User($id: Int) {
  user(id: $id) {
    name
    email
    conventions {
      ...MetaConventionFragment
    }
  }
}

query FullConvention($id: Int, $code: String!) {
  userConvention(id: $id, code: $code) {
    ...FullConventionFragment
  }
}

query ConventionPage($date: DateTimeFixedOffset, $limit: Int, $page: Int) {
  convention(date: $date, limit: $limit, page: $page) {
    page
    pages
    data {
      id
      name
      code
      start
      end
    }
  }
}

mutation AddRecord($id: Int, $record: RecordAdd!) {
  addUserRecord(userId: $id, record: $record) {
    ...RecordFragment
  }
}

mutation AddExpense($id: Int, $expense: ExpenseAdd!) {
  addUserExpense(userId: $id, expense: $expense) {
    ...ExpenseFragment
  }
}
